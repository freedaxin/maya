#include <v8.h>
#include <node.h>
#include <node_buffer.h>

#include <string>
#include <vector>
#include <set>
#include <cctype>
#include <algorithm>

#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>

#include <glib.h>

#include "sql-tokenizer.h"

using namespace std;
using namespace node;
using namespace v8;

// Use these macro to fetch parameters from Arguments object
#define REQ_FUN_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsFunction())                   \
    return ThrowException(Exception::TypeError(                         \
                  String::New("Argument " #I " must be a function")));  \
  Local<Function> VAR = Local<Function>::Cast(args[I]);

#define REQ_STR_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsString())                 \
    return ThrowException(Exception::TypeError(                         \
                  String::New("Argument " #I " must be a string")));    \
  Local<String> VAR = Local<String>::Cast(args[I]);


#define REQ_INT_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsNumber())                     \
    return ThrowException(Exception::TypeError(                         \
                  String::New("Argument " #I " must be a integer")));    \
  Local<Integer> VAR = Local<Integer>::Cast(args[I]);

typedef enum {
  PR_SUCCESS = 0,
  PR_USE_DEFAULT_DB = 1,
  PR_USE_ALL_SHARDS,
  PR_ERROR,
  PR_NOT_SUPPORTED,
} ParseResult;

typedef std::vector<std::string> StringVector;

static Persistent<String> operation_sym = NODE_PSYMBOL("operation");
static Persistent<String> is_read_sym = NODE_PSYMBOL("is_read");
static Persistent<String> table_name_sym = NODE_PSYMBOL("table_name");
static Persistent<String> db_name_sym = NODE_PSYMBOL("db_name");

class SqlParser: ObjectWrap
{
private:
  GPtrArray *tokens; // store parsed tokens;

  string originSQL;
  string newSQL;

  ParseResult result;
  string errorMessage;
  string dbName;
  string tableName;
  int posTableName;
  bool parsed;
  int posTokenWhere;
  int posTokenSet;
  int posTokenValues;

public:

  ////////////// Instance Method ////////////////////
  void reset() {
    if(tokens->len != 0 || tokens->pdata) {
        sql_tokens_free(tokens);
        tokens = g_ptr_array_new();
    }
    parsed = false;
    newSQL.clear();
    dbName.clear();
    tableName.clear();
    posTableName = -1;
    posTokenWhere = -1;
    posTokenSet = -1;
    posTokenValues = -1;

    handle_->Set(operation_sym, Undefined());
    handle_->Set(is_read_sym, False());
    handle_->Set(table_name_sym, Undefined());
    handle_->Set(db_name_sym, Undefined());
  }

  int getTokensLen() const { return tokens->len; }

  void getSQL(string newDBName, string newTableName) {
    newSQL.clear();
    bool replace_dbname = (newDBName.length() > 0);
    bool replaced = false;
    for(int i = 0; i < getTokensLen(); i ++) {
      replaced = false;
      switch (getTokenId(i)) {
        case TK_LITERAL:
        {
          newSQL.push_back('`');
          if (replace_dbname)
          {
            if (getTokenId(i+1) == TK_DOT && tableName.compare(getTokenStr(i+2)) == 0)
            {
              newSQL.append(newDBName);
              newSQL.append("`.`");
              newSQL.append(newTableName);
              i += 2;
              replaced = true;
            }
            else if (tableName.compare(getTokenStr(i)) == 0)
            {
              newSQL.append(newDBName);
              newSQL.append("`.`");
              newSQL.append(newTableName);
              replaced = true;
            }
          }
          else{
            if (tableName.compare(getTokenStr(i)) == 0)
            {
              newSQL.append(newTableName);
              replaced = true;
            }
          }
          if (!replaced)
          {
            newSQL.append(getTokenStr(i));
          }
          newSQL.push_back('`');
          break;
        }
        case TK_STRING:
        {
          newSQL.push_back('\'');
          newSQL.append(getTokenStr(i));
          newSQL.push_back('\'');
          break;
        }
        case TK_COMMENT:
        {
          newSQL.append("/*");
          newSQL.append(getTokenStr(i));
          newSQL.append("*/");
          break;
        }
        case TK_COMMENT_MYSQL:
        {
          newSQL.append("/*!");
          newSQL.append(getTokenStr(i));
          newSQL.append("*/");
          break;
        }
        case TK_UNKNOWN: break;
        default:
        {
          newSQL.append(getTokenStr(i));
        }
      }
      newSQL.push_back(' ');
    }
    // erase space at last
    newSQL.erase(newSQL.length()-1);
  }

  string getTokenStr(int idx) const
  {
    if ((unsigned int)idx >= tokens->len) {
      return "";
    } else {
      const sql_token *tk = (const sql_token *)(tokens->pdata[idx]);
      return string(tk->text->str, tk->text->len);
    }
  }


  int tokComp(int idx, const string &str) const
  {
    const sql_token *tk = (const sql_token *)(tokens->pdata[idx]);
    char *cstr = new char [tk->text->len + 1];

    strcpy(cstr, tk->text->str);

    int i;
    for (i = 0; cstr[i]; i++) {
      cstr[i] = tolower(cstr[i]);
    }

    bool r =  str.compare(0, str.size(), cstr, tk->text->len);
    delete cstr;

    return r;
  }

  sql_token_id getTokenId(int idx) const
  {
    if ((unsigned int)idx >= tokens->len) {
      return TK_LAST_TOKEN;
    } else {
      return ((const sql_token *)(tokens->pdata[idx]))->token_id;
    }
  }


  uint64_t tokenToUint64(int idx) const
  {
      uint64_t b = 0;
      const sql_token *tk = (const sql_token *)(tokens->pdata[idx]);

      const char *p = tk->text->str;
      for (size_t i = 0; i < tk->text->len; i++, p++) {
          b = b * 10 + *p - '0';
      }
      return b;
  }


  bool findToken(int start, int end, int tokId, int *where) const
  {
      int i = start;

      while(i < end && getTokenId(i) != tokId)
          i++;

      *where = i;
      return i < end;
  }

  bool findTokens(int start, int end, int *tokIds, int size, int *where) const
  {
      int i;
      for (i=start; i < end; i++) {
          int id = getTokenId(i);
          for (int k = 0; k < size; k++) {
              if (tokIds[k] == id) {
                  *where = i;
                  return true;
              }
          }
      }

      *where = i;
      return false;
  }

  bool parseSelect()
  {
    for(int i = 1; i < getTokensLen(); i ++) {
      switch (getTokenId(i)) {
        case TK_SQL_FROM:
        {
          if (getTokenId(i+2) == TK_DOT)
          {
            if (TK_LITERAL != getTokenId(i+1))
            {
              return false;
            }
            dbName = getTokenStr(i+1);
            posTableName = i+3;
            i+=3;
          } else {
            posTableName = i+1;
            i+=1;
          }
          if (TK_LITERAL != getTokenId(posTableName))
          {
            return false;
          }
          tableName = getTokenStr(posTableName);
          break;
        }
        case TK_SQL_WHERE:
        {
          posTokenWhere = i;
          // return when find first where
          return true;
        }
        default:
          break;
      }
    }
    return true;
  }

  bool parseUpdate()
  {
    for(int i = 1; i < getTokensLen(); i ++) {
      switch (getTokenId(i)) {
        case TK_SQL_SET:
        {
          posTableName = i-1;
          if (getTokenId(i-2) == TK_DOT)
          {
            if (TK_LITERAL != getTokenId(i-3))
            {
              return false;
            }
            dbName = getTokenStr(i-3);
          }
          if (TK_LITERAL != getTokenId(posTableName))
          {
            return false;
          }
          tableName = getTokenStr(posTableName);
          break;
        }
        case TK_SQL_WHERE:
        {
          posTokenWhere = i;
          // return when find first where
          return true;
        }
        default:
          break;
      }
    }
    return true;
  }

  bool parseInsert()
  {
    int i = (getTokenId(1) == TK_SQL_INTO) ? 2 : 1;
    if (getTokenId(i+1) == TK_DOT)
    {
      if (TK_LITERAL != getTokenId(i))
      {
        return false;
      }
      dbName = getTokenStr(i);
      posTableName = i+2;
      i+=2;
    } else {
      posTableName = i;
    }
    if (TK_LITERAL != getTokenId(posTableName))
    {
      return false;
    }
    tableName = getTokenStr(posTableName);

    for(int i = posTableName+1; i < getTokensLen(); i ++) {
      switch (getTokenId(i)) {
        // return when find first set or values
        case TK_SQL_VALUES:
        case TK_SQL_VALUE:
          posTokenValues = i;
          return true;
        case TK_SQL_SET:
          posTokenSet = i;
          return true;
        default:
          break;
      }
    }
    return true;
  }

  bool getRowKeyValueByTKIndex(unsigned int rk_idx,
                              Handle<v8::Array> &rkvs,
                              unsigned int set_idx) const
  {
    if (rk_idx >= (unsigned int)this->getTokensLen()) {
      return false;
    }
    string rkv = this->getTokenStr(rk_idx);
    switch (this->getTokenId(rk_idx)) {
      case TK_INTEGER:
      {
        rkvs->Set(set_idx, Integer::New(atoi(rkv.c_str())));
        break;
      }
      default:
      {
        rkvs->Set(set_idx, String::New(rkv.c_str()));
      }
    }
    return true;
  }

  bool getRowKeyValueByCondition(Handle<v8::Array> &rkvs, string row_key, int start_idx) const
  {
    int rk_idx = 0;
    for(int i = start_idx+1; 0 == rk_idx && i < this->getTokensLen(); i++) {
      int token_id = getTokenId(i);
      switch (token_id) {
        case TK_SQL_GROUP:
        case TK_SQL_HAVING:
        case TK_SQL_ORDER:
        case TK_SQL_LIMIT:
        case TK_SQL_PROCEDURE:
        case TK_SQL_INTO:
        case TK_SQL_FOR:
        case TK_SQL_LOCK:
        {
          return false;
        }
        case TK_LITERAL:
        {
          if(this->tokComp(i,row_key) == 0) {
            rk_idx = i;
            break;
          }
        }
        default:
        {
          break;
        }
      }
    }
    if (0 == rk_idx) {
      return false;
    }
    unsigned int set_idx = 0;
    sql_token_id id = this->getTokenId(rk_idx + 1);
    if(id == TK_EQ) {
      rk_idx += 2;
      this->getRowKeyValueByTKIndex(rk_idx, rkvs, set_idx);
    } else if(id == TK_SQL_IN) {
      rk_idx += 3;
      int tid = this->getTokenId(rk_idx);
      while (tid != TK_CBRACE && tid != TK_LAST_TOKEN) {
        if (tid != TK_COMMA) {
          this->getRowKeyValueByTKIndex(rk_idx, rkvs, set_idx);
          ++set_idx;
        }
        ++rk_idx;
        tid = this->getTokenId(rk_idx);
      }
    }
    return true;
  }

  bool getRowKeyValueByValues(Handle<v8::Array> &rkvs, string row_key)
  {
    int posOBRACE = -1; // pos of (
    int rowKeyIndex = -1; // rowkey distance to (
    int token_id = -1;
    for(int i = posTableName + 1; i < this->getTokensLen(); i ++) {
      token_id = getTokenId(i);
      if (-1 == posOBRACE)
      {
        if (TK_OBRACE == token_id)
        {
          posOBRACE = i;
        }
        continue;
      }
      if(TK_LITERAL == token_id && this->tokComp(i,row_key) == 0) {
        rowKeyIndex = i - posOBRACE;
      }
    }
    if(-1 == rowKeyIndex) {
      // no row key
      return false;
    }
    int rowKeyValuePos = posTokenValues + rowKeyIndex + 1;
    return this->getRowKeyValueByTKIndex(rowKeyValuePos, rkvs, 0);
  }
  ////////////// V8 Stuff ///////////////////////////

  static Persistent<FunctionTemplate> s_ct;


  static void Init(Handle<Object> target) {
    HandleScope scope;

    Local<FunctionTemplate> t = FunctionTemplate::New(New);

    s_ct = Persistent<FunctionTemplate>::New(t);
    s_ct->InstanceTemplate()->SetInternalFieldCount(1);
    s_ct->SetClassName(String::NewSymbol("SqlParser"));


    NODE_SET_PROTOTYPE_METHOD(s_ct, "init", SqlParserInit);
    NODE_SET_PROTOTYPE_METHOD(s_ct, "parse", Parse);
    NODE_SET_PROTOTYPE_METHOD(s_ct, "getRowKeyValue", GetRowKeyValue);
    NODE_SET_PROTOTYPE_METHOD(s_ct, "replaceTableName", ReplaceTableName);
    NODE_SET_PROTOTYPE_METHOD(s_ct, "getParseResult", GetParseResult);
    NODE_SET_PROTOTYPE_METHOD(s_ct, "getErrorMessage", GetErrorMessage);
    NODE_SET_PROTOTYPE_METHOD(s_ct, "getAllTokens", GetAllTokens);
    NODE_SET_PROTOTYPE_METHOD(s_ct, "printAllTokens", PrintAllTokens);
    NODE_SET_PROTOTYPE_METHOD(s_ct, "getTokenName", GetTokenName);

    target->Set(String::NewSymbol("SqlParser"),
                 s_ct->GetFunction());
  }

  SqlParser() {
     tokens = g_ptr_array_new();
     parsed = false;
     newSQL = "";
     posTableName = -1;
     posTokenWhere = -1;
     posTokenSet = -1;
     posTokenValues = -1;
  }

  ~SqlParser() {
     sql_tokens_free(tokens);
  }



  static Handle<Value> New(const Arguments& args){
    HandleScope scope;
    SqlParser* sp = new SqlParser();
    sp->Wrap(args.This());
    return args.This();
  }

  static Handle<Value> Close(const Arguments& args) {
    HandleScope scope;

    return Undefined();
  }

  ////////////////////// Exported Method /////////////////


  static Handle<Value> GetParseResult(const Arguments& args) {
    HandleScope scope;

    SqlParser* wrap = ObjectWrap::Unwrap<SqlParser>(args.This());
    return scope.Close(Integer::New(wrap->result));

  }

  static Handle<Value> GetErrorMessage(const Arguments& args) {
    HandleScope scope;

    SqlParser* wrap = ObjectWrap::Unwrap<SqlParser>(args.This());
    return scope.Close(String::New(wrap->errorMessage.c_str()));

  }

  static Handle<Value> SqlParserInit(const Arguments& args) {
    HandleScope scope;

    return Undefined();
  }

  static Handle<Value> Parse(const Arguments& args) {
    HandleScope scope;
    SqlParser* wrap = ObjectWrap::Unwrap<SqlParser>(args.This());
    wrap->reset();

    Local<Value> sql_buf = args[0];
    if (Buffer::HasInstance(sql_buf)) {
      size_t sql_size = Buffer::Length(sql_buf->ToObject());
      char* bufferdata = Buffer::Data(sql_buf->ToObject());
      sql_tokenizer(wrap->tokens, bufferdata, sql_size);
    } else {
      REQ_STR_ARG(0,sql);
      char sql_tmp[sql->Utf8Length()];
      sql->WriteUtf8(sql_tmp);
      sql_tokenizer(wrap->tokens, sql_tmp, sql->Utf8Length());
    }
    StringVector tables, aliases;

    if (wrap->getTokensLen() <= 0) {
      wrap->result = PR_ERROR;
      return scope.Close(Boolean::New(false));
    }
    wrap->handle_->Set(operation_sym, Number::New(wrap->getTokenId(0)));
    switch (wrap->getTokenId(0)) {
      // select and delete has no difference
      case TK_SQL_EXPLAIN:
      case TK_SQL_SELECT:
        wrap->handle_->Set(is_read_sym, True());
      case TK_SQL_DELETE:
      {
        wrap->parseSelect();
        break;
      }
      case TK_SQL_UPDATE:
      {
        wrap->parseUpdate();
        break;
      }
      case TK_SQL_INSERT:
      case TK_SQL_REPLACE:
      {
        // support format:
        // INSERT/REPLACE  ... <table> (...) VALUES (....)
        // INSERT/REPLACE  ... <table> set k=v
        wrap->parseInsert();
        break;
      }
      default:
      {
        break;
      }
    }
    wrap->handle_->Set(table_name_sym, String::New(wrap->tableName.c_str()));
    wrap->handle_->Set(db_name_sym, String::New(wrap->dbName.c_str()));
    wrap->result = PR_SUCCESS;
    wrap->parsed = true;
    return scope.Close(Boolean::New(true));
  }

  static Handle<Value> GetRowKeyValue(const Arguments& args) {
    HandleScope scope;
    Handle<v8::Array> rkvs = v8::Array::New();
    SqlParser* wrap = ObjectWrap::Unwrap<SqlParser>(args.This());
    if(!wrap->parsed || wrap->result != PR_SUCCESS) {
        return scope.Close(rkvs);
    }

    REQ_STR_ARG(0,row_key);

    char row_key_tmp[row_key->Length()];
    row_key->WriteUtf8(row_key_tmp);

    switch (wrap->getTokenId(0)) {
      case TK_SQL_EXPLAIN:
      case TK_SQL_SELECT:
      case TK_SQL_UPDATE:
      case TK_SQL_DELETE:
      {
        wrap->getRowKeyValueByCondition(rkvs, string(row_key_tmp), wrap->posTokenWhere);
        break;
      }
      case TK_SQL_INSERT:
      case TK_SQL_REPLACE:
      { // support format: INSERT/REPLACE  ... <table> (...) VALUES (....)
        if (wrap->posTokenValues >= 0)
        {
          wrap->getRowKeyValueByValues(rkvs, string(row_key_tmp));
        }
        else
        {
          wrap->getRowKeyValueByCondition(rkvs, string(row_key_tmp), wrap->posTokenSet);
        }
        break;
      }
      default:
      {
        break;
      }
    }

    return scope.Close(rkvs);
  }

  static Handle<Value> ReplaceTableName(const Arguments& args) {
    HandleScope scope;
    SqlParser* wrap = ObjectWrap::Unwrap<SqlParser>(args.This());

    if(0 == wrap->posTableName || !wrap->parsed || wrap->result != PR_SUCCESS) {
        return Undefined();
    }

    REQ_STR_ARG(0,dbname);
    REQ_STR_ARG(1,tname);
    char dbname_tmp[dbname->Length()+1];
    char tname_tmp[tname->Length()+1];
    dbname->WriteUtf8(dbname_tmp);
    tname->WriteUtf8(tname_tmp);
    wrap->getSQL(string(dbname_tmp), string(tname_tmp));
    return scope.Close(String::New(wrap->newSQL.c_str()));
  }

  static Handle<Value> GetAllTokens(const Arguments& args) {
    HandleScope scope;
    SqlParser* wrap = ObjectWrap::Unwrap<SqlParser>(args.This());

    Handle<v8::Array> rkvs = v8::Array::New();
    for(int i = 0; i < wrap->getTokensLen(); i++) {
      string s;
      switch (wrap->getTokenId(i)) {
        case TK_STRING:
        {
          s.push_back('\'');
          s.append(wrap->getTokenStr(i));
          s.push_back('\'');
          break;
        }
        case TK_COMMENT:
        {
          s.append("/*");
          s.append(wrap->getTokenStr(i));
          s.append("*/");
          break;
        }
        case TK_COMMENT_MYSQL:
        {
          s.append("/*!");
          s.append(wrap->getTokenStr(i));
          s.append("*/");
          break;
        }
        default:
        {
          s = wrap->getTokenStr(i);
          break;
        }
      }
      rkvs->Set(i, String::New(s.c_str()));
    }

    return scope.Close(rkvs);
  }

  // for debug
  static Handle<Value> PrintAllTokens(const Arguments& args) {
    SqlParser* wrap = ObjectWrap::Unwrap<SqlParser>(args.This());
    for(int i = 0; i < wrap->getTokensLen(); i ++) {
      printf("token: %s, content: %s\n", sql_token_get_name(wrap->getTokenId(i)), wrap->getTokenStr(i).c_str());
    }
    return Undefined();
  }
  static Handle<Value> GetTokenName(const Arguments& args) {
    HandleScope scope;
    REQ_INT_ARG(0, token_id);
    return scope.Close(String::New(sql_token_get_name((sql_token_id)(token_id->Int32Value()))));
  }
};

Persistent<FunctionTemplate> SqlParser::s_ct;

extern "C" {
  HandleScope scope;
  void init (Handle<Object> target) {
    SqlParser::Init(target);
  }
  NODE_MODULE(sqlparser,init);
}
